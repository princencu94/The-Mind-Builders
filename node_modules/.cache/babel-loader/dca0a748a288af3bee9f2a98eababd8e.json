{"ast":null,"code":"import { match } from './match.esm.js'; //  - https://stackoverflow.com/a/30753870\n\nvar focusableSelector = /*#__PURE__*/['[contentEditable=true]', '[tabindex]', 'a[href]', 'area[href]', 'button:not([disabled])', 'iframe', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])'].map(process.env.NODE_ENV === 'test' ? // TODO: Remove this once JSDOM fixes the issue where an element that is\n// \"hidden\" can be the document.activeElement, because this is not possible\n// in real browsers.\n// TODO: Remove this once JSDOM fixes the issue where an element that is\nfunction (selector) {\n  return selector + \":not([tabindex='-1']):not([style*='display: none'])\";\n} : function (selector) {\n  return selector + \":not([tabindex='-1'])\";\n}).join(',');\nvar Focus;\n\n(function (Focus) {\n  /** Focus the first non-disabled element */\n  Focus[Focus[\"First\"] = 1] = \"First\";\n  /** Focus the previous non-disabled element */\n\n  Focus[Focus[\"Previous\"] = 2] = \"Previous\";\n  /** Focus the next non-disabled element */\n\n  Focus[Focus[\"Next\"] = 4] = \"Next\";\n  /** Focus the last non-disabled element */\n\n  Focus[Focus[\"Last\"] = 8] = \"Last\";\n  /** Wrap tab around */\n\n  Focus[Focus[\"WrapAround\"] = 16] = \"WrapAround\";\n  /** Prevent scrolling the focusable elements into view */\n\n  Focus[Focus[\"NoScroll\"] = 32] = \"NoScroll\";\n})(Focus || (Focus = {}));\n\nvar FocusResult;\n\n(function (FocusResult) {\n  /** Something went wrong while trying to focus. */\n  FocusResult[FocusResult[\"Error\"] = 0] = \"Error\";\n  /** When `Focus.WrapAround` is enabled, going from position `N` to `N+1` where `N` is the last index in the array, then we overflow. */\n\n  FocusResult[FocusResult[\"Overflow\"] = 1] = \"Overflow\";\n  /** Focus was successful. */\n\n  FocusResult[FocusResult[\"Success\"] = 2] = \"Success\";\n  /** When `Focus.WrapAround` is enabled, going from position `N` to `N-1` where `N` is the first index in the array, then we underflow. */\n\n  FocusResult[FocusResult[\"Underflow\"] = 3] = \"Underflow\";\n})(FocusResult || (FocusResult = {}));\n\nvar Direction;\n\n(function (Direction) {\n  Direction[Direction[\"Previous\"] = -1] = \"Previous\";\n  Direction[Direction[\"Next\"] = 1] = \"Next\";\n})(Direction || (Direction = {}));\n\nfunction getFocusableElements(container) {\n  if (container === void 0) {\n    container = document.body;\n  }\n\n  if (container == null) return [];\n  return Array.from(container.querySelectorAll(focusableSelector));\n}\n\nvar FocusableMode;\n\n(function (FocusableMode) {\n  /** The element itself must be focusable. */\n  FocusableMode[FocusableMode[\"Strict\"] = 0] = \"Strict\";\n  /** The element should be inside of a focusable element. */\n\n  FocusableMode[FocusableMode[\"Loose\"] = 1] = \"Loose\";\n})(FocusableMode || (FocusableMode = {}));\n\nfunction isFocusableElement(element, mode) {\n  var _match;\n\n  if (mode === void 0) {\n    mode = FocusableMode.Strict;\n  }\n\n  if (element === document.body) return false;\n  return match(mode, (_match = {}, _match[FocusableMode.Strict] = function () {\n    return element.matches(focusableSelector);\n  }, _match[FocusableMode.Loose] = function () {\n    var next = element;\n\n    while (next !== null) {\n      if (next.matches(focusableSelector)) return true;\n      next = next.parentElement;\n    }\n\n    return false;\n  }, _match));\n}\n\nfunction focusElement(element) {\n  element == null ? void 0 : element.focus({\n    preventScroll: true\n  });\n}\n\nfunction focusIn(container, focus) {\n  var elements = Array.isArray(container) ? container : getFocusableElements(container);\n  var active = document.activeElement;\n\n  var direction = function () {\n    if (focus & (Focus.First | Focus.Next)) return Direction.Next;\n    if (focus & (Focus.Previous | Focus.Last)) return Direction.Previous;\n    throw new Error('Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last');\n  }();\n\n  var startIndex = function () {\n    if (focus & Focus.First) return 0;\n    if (focus & Focus.Previous) return Math.max(0, elements.indexOf(active)) - 1;\n    if (focus & Focus.Next) return Math.max(0, elements.indexOf(active)) + 1;\n    if (focus & Focus.Last) return elements.length - 1;\n    throw new Error('Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last');\n  }();\n\n  var focusOptions = focus & Focus.NoScroll ? {\n    preventScroll: true\n  } : {};\n  var offset = 0;\n  var total = elements.length;\n  var next = undefined;\n\n  do {\n    var _next; // Guard against infinite loops\n\n\n    if (offset >= total || offset + total <= 0) return FocusResult.Error;\n    var nextIdx = startIndex + offset;\n\n    if (focus & Focus.WrapAround) {\n      nextIdx = (nextIdx + total) % total;\n    } else {\n      if (nextIdx < 0) return FocusResult.Underflow;\n      if (nextIdx >= total) return FocusResult.Overflow;\n    }\n\n    next = elements[nextIdx]; // Try the focus the next element, might not work if it is \"hidden\" to the user.\n\n    (_next = next) == null ? void 0 : _next.focus(focusOptions); // Try the next one in line\n\n    offset += direction;\n  } while (next !== document.activeElement); // This is a little weird, but let me try and explain: There are a few scenario's\n  // in chrome for example where a focused `<a>` tag does not get the default focus\n  // styles and sometimes they do. This highly depends on whether you started by\n  // clicking or by using your keyboard. When you programmatically add focus `anchor.focus()`\n  // then the active element (document.activeElement) is this anchor, which is expected.\n  // However in that case the default focus styles are not applied *unless* you\n  // also add this tabindex.\n\n\n  if (!next.hasAttribute('tabindex')) next.setAttribute('tabindex', '0');\n  return FocusResult.Success;\n}\n\nexport { Focus, FocusResult, FocusableMode, focusElement, focusIn, getFocusableElements, isFocusableElement };","map":{"version":3,"sources":["../../src/utils/focus-management.ts"],"names":["focusableSelector","selector","Focus","FocusResult","Direction","getFocusableElements","container","document","body","Array","FocusableMode","isFocusableElement","element","mode","Strict","match","next","focusElement","preventScroll","focusIn","focus","elements","active","direction","startIndex","Math","focusOptions","offset","total","nextIdx"],"mappings":"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","sourcesContent":["import { match } from './match'\n\n// Credit:\n//  - https://stackoverflow.com/a/30753870\nlet focusableSelector = [\n  '[contentEditable=true]',\n  '[tabindex]',\n  'a[href]',\n  'area[href]',\n  'button:not([disabled])',\n  'iframe',\n  'input:not([disabled])',\n  'select:not([disabled])',\n  'textarea:not([disabled])',\n]\n  .map(\n    process.env.NODE_ENV === 'test'\n      ? // TODO: Remove this once JSDOM fixes the issue where an element that is\n        // \"hidden\" can be the document.activeElement, because this is not possible\n        // in real browsers.\n        selector => `${selector}:not([tabindex='-1']):not([style*='display: none'])`\n      : selector => `${selector}:not([tabindex='-1'])`\n  )\n  .join(',')\n\nexport enum Focus {\n  /** Focus the first non-disabled element */\n  First = 1 << 0,\n\n  /** Focus the previous non-disabled element */\n  Previous = 1 << 1,\n\n  /** Focus the next non-disabled element */\n  Next = 1 << 2,\n\n  /** Focus the last non-disabled element */\n  Last = 1 << 3,\n\n  /** Wrap tab around */\n  WrapAround = 1 << 4,\n\n  /** Prevent scrolling the focusable elements into view */\n  NoScroll = 1 << 5,\n}\n\nexport enum FocusResult {\n  /** Something went wrong while trying to focus. */\n  Error,\n\n  /** When `Focus.WrapAround` is enabled, going from position `N` to `N+1` where `N` is the last index in the array, then we overflow. */\n  Overflow,\n\n  /** Focus was successful. */\n  Success,\n\n  /** When `Focus.WrapAround` is enabled, going from position `N` to `N-1` where `N` is the first index in the array, then we underflow. */\n  Underflow,\n}\n\nenum Direction {\n  Previous = -1,\n  Next = 1,\n}\n\nexport function getFocusableElements(container: HTMLElement | null = document.body) {\n  if (container == null) return []\n  return Array.from(container.querySelectorAll<HTMLElement>(focusableSelector))\n}\n\nexport enum FocusableMode {\n  /** The element itself must be focusable. */\n  Strict,\n\n  /** The element should be inside of a focusable element. */\n  Loose,\n}\n\nexport function isFocusableElement(\n  element: HTMLElement,\n  mode: FocusableMode = FocusableMode.Strict\n) {\n  if (element === document.body) return false\n\n  return match(mode, {\n    [FocusableMode.Strict]() {\n      return element.matches(focusableSelector)\n    },\n    [FocusableMode.Loose]() {\n      let next: HTMLElement | null = element\n\n      while (next !== null) {\n        if (next.matches(focusableSelector)) return true\n        next = next.parentElement\n      }\n\n      return false\n    },\n  })\n}\n\nexport function focusElement(element: HTMLElement | null) {\n  element?.focus({ preventScroll: true })\n}\n\nexport function focusIn(container: HTMLElement | HTMLElement[], focus: Focus) {\n  let elements = Array.isArray(container) ? container : getFocusableElements(container)\n  let active = document.activeElement as HTMLElement\n\n  let direction = (() => {\n    if (focus & (Focus.First | Focus.Next)) return Direction.Next\n    if (focus & (Focus.Previous | Focus.Last)) return Direction.Previous\n\n    throw new Error('Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last')\n  })()\n\n  let startIndex = (() => {\n    if (focus & Focus.First) return 0\n    if (focus & Focus.Previous) return Math.max(0, elements.indexOf(active)) - 1\n    if (focus & Focus.Next) return Math.max(0, elements.indexOf(active)) + 1\n    if (focus & Focus.Last) return elements.length - 1\n\n    throw new Error('Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last')\n  })()\n\n  let focusOptions = focus & Focus.NoScroll ? { preventScroll: true } : {}\n\n  let offset = 0\n  let total = elements.length\n  let next = undefined\n  do {\n    // Guard against infinite loops\n    if (offset >= total || offset + total <= 0) return FocusResult.Error\n\n    let nextIdx = startIndex + offset\n\n    if (focus & Focus.WrapAround) {\n      nextIdx = (nextIdx + total) % total\n    } else {\n      if (nextIdx < 0) return FocusResult.Underflow\n      if (nextIdx >= total) return FocusResult.Overflow\n    }\n\n    next = elements[nextIdx]\n\n    // Try the focus the next element, might not work if it is \"hidden\" to the user.\n    next?.focus(focusOptions)\n\n    // Try the next one in line\n    offset += direction\n  } while (next !== document.activeElement)\n\n  // This is a little weird, but let me try and explain: There are a few scenario's\n  // in chrome for example where a focused `<a>` tag does not get the default focus\n  // styles and sometimes they do. This highly depends on whether you started by\n  // clicking or by using your keyboard. When you programmatically add focus `anchor.focus()`\n  // then the active element (document.activeElement) is this anchor, which is expected.\n  // However in that case the default focus styles are not applied *unless* you\n  // also add this tabindex.\n  if (!next.hasAttribute('tabindex')) next.setAttribute('tabindex', '0')\n\n  return FocusResult.Success\n}\n"]},"metadata":{},"sourceType":"module"}