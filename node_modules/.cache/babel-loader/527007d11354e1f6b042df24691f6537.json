{"ast":null,"code":"import { disposables } from '../../../utils/disposables.esm.js';\nimport { once } from '../../../utils/once.esm.js';\n\nfunction addClasses(node) {\n  var _node$classList;\n\n  for (var _len = arguments.length, classes = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    classes[_key - 1] = arguments[_key];\n  }\n\n  node && classes.length > 0 && (_node$classList = node.classList).add.apply(_node$classList, classes);\n}\n\nfunction removeClasses(node) {\n  var _node$classList2;\n\n  for (var _len2 = arguments.length, classes = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    classes[_key2 - 1] = arguments[_key2];\n  }\n\n  node && classes.length > 0 && (_node$classList2 = node.classList).remove.apply(_node$classList2, classes);\n}\n\nvar Reason;\n\n(function (Reason) {\n  Reason[\"Finished\"] = \"finished\";\n  Reason[\"Cancelled\"] = \"cancelled\";\n})(Reason || (Reason = {}));\n\nfunction waitForTransition(node, done) {\n  var d = disposables();\n  if (!node) return d.dispose; // Safari returns a comma separated list of values, so let's sort them and take the highest value.\n\n  var _getComputedStyle = getComputedStyle(node),\n      transitionDuration = _getComputedStyle.transitionDuration,\n      transitionDelay = _getComputedStyle.transitionDelay;\n\n  var _map = [transitionDuration, transitionDelay].map(function (value) {\n    var _value$split$filter$m = value.split(',') // Remove falsy we can't work with\n    .filter(Boolean) // Values are returned as `0.3s` or `75ms`\n    .map(function (v) {\n      return v.includes('ms') ? parseFloat(v) : parseFloat(v) * 1000;\n    }).sort(function (a, z) {\n      return z - a;\n    }),\n        _value$split$filter$m2 = _value$split$filter$m[0],\n        resolvedValue = _value$split$filter$m2 === void 0 ? 0 : _value$split$filter$m2;\n\n    return resolvedValue;\n  }),\n      durationMs = _map[0],\n      delaysMs = _map[1]; // Waiting for the transition to end. We could use the `transitionend` event, however when no\n  // actual transition/duration is defined then the `transitionend` event is not fired.\n  //\n  // TODO: Downside is, when you slow down transitions via devtools this timeout is still using the\n  // full 100% speed instead of the 25% or 10%.\n\n\n  if (durationMs !== 0) {\n    d.setTimeout(function () {\n      done(Reason.Finished);\n    }, durationMs + delaysMs);\n  } else {\n    // No transition is happening, so we should cleanup already. Otherwise we have to wait until we\n    // get disposed.\n    done(Reason.Finished);\n  } // If we get disposed before the timeout runs we should cleanup anyway\n\n\n  d.add(function () {\n    return done(Reason.Cancelled);\n  });\n  return d.dispose;\n}\n\nfunction transition(node, base, from, to, entered, done) {\n  var d = disposables();\n\n  var _done = done !== undefined ? once(done) : function () {};\n\n  removeClasses.apply(void 0, [node].concat(entered));\n  addClasses.apply(void 0, [node].concat(base, from));\n  d.nextFrame(function () {\n    removeClasses.apply(void 0, [node].concat(from));\n    addClasses.apply(void 0, [node].concat(to));\n    d.add(waitForTransition(node, function (reason) {\n      removeClasses.apply(void 0, [node].concat(to, base));\n      addClasses.apply(void 0, [node].concat(entered));\n      return _done(reason);\n    }));\n  }); // Once we get disposed, we should ensure that we cleanup after ourselves. In case of an unmount,\n  // the node itself will be nullified and will be a no-op. In case of a full transition the classes\n  // are already removed which is also a no-op. However if you go from enter -> leave mid-transition\n  // then we have some leftovers that should be cleaned.\n\n  d.add(function () {\n    return removeClasses.apply(void 0, [node].concat(base, from, to, entered));\n  }); // When we get disposed early, than we should also call the done method but switch the reason.\n\n  d.add(function () {\n    return _done(Reason.Cancelled);\n  });\n  return d.dispose;\n}\n\nexport { Reason, transition };","map":{"version":3,"sources":["../../../../src/components/transitions/utils/transition.ts"],"names":["classes","node","Reason","d","disposables","transitionDuration","transitionDelay","getComputedStyle","durationMs","delaysMs","resolvedValue","v","parseFloat","z","done","transition","base","from","to","entered","_done","once","removeClasses","addClasses","waitForTransition"],"mappings":"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","sourcesContent":["import { once } from '../../../utils/once'\nimport { disposables } from '../../../utils/disposables'\n\nfunction addClasses(node: HTMLElement, ...classes: string[]) {\n  node && classes.length > 0 && node.classList.add(...classes)\n}\n\nfunction removeClasses(node: HTMLElement, ...classes: string[]) {\n  node && classes.length > 0 && node.classList.remove(...classes)\n}\n\nexport enum Reason {\n  Finished = 'finished',\n  Cancelled = 'cancelled',\n}\n\nfunction waitForTransition(node: HTMLElement, done: (reason: Reason) => void) {\n  let d = disposables()\n\n  if (!node) return d.dispose\n\n  // Safari returns a comma separated list of values, so let's sort them and take the highest value.\n  let { transitionDuration, transitionDelay } = getComputedStyle(node)\n\n  let [durationMs, delaysMs] = [transitionDuration, transitionDelay].map(value => {\n    let [resolvedValue = 0] = value\n      .split(',')\n      // Remove falsy we can't work with\n      .filter(Boolean)\n      // Values are returned as `0.3s` or `75ms`\n      .map(v => (v.includes('ms') ? parseFloat(v) : parseFloat(v) * 1000))\n      .sort((a, z) => z - a)\n\n    return resolvedValue\n  })\n\n  // Waiting for the transition to end. We could use the `transitionend` event, however when no\n  // actual transition/duration is defined then the `transitionend` event is not fired.\n  //\n  // TODO: Downside is, when you slow down transitions via devtools this timeout is still using the\n  // full 100% speed instead of the 25% or 10%.\n  if (durationMs !== 0) {\n    d.setTimeout(() => {\n      done(Reason.Finished)\n    }, durationMs + delaysMs)\n  } else {\n    // No transition is happening, so we should cleanup already. Otherwise we have to wait until we\n    // get disposed.\n    done(Reason.Finished)\n  }\n\n  // If we get disposed before the timeout runs we should cleanup anyway\n  d.add(() => done(Reason.Cancelled))\n\n  return d.dispose\n}\n\nexport function transition(\n  node: HTMLElement,\n  base: string[],\n  from: string[],\n  to: string[],\n  entered: string[],\n  done?: (reason: Reason) => void\n) {\n  let d = disposables()\n  let _done = done !== undefined ? once(done) : () => {}\n\n  removeClasses(node, ...entered)\n  addClasses(node, ...base, ...from)\n\n  d.nextFrame(() => {\n    removeClasses(node, ...from)\n    addClasses(node, ...to)\n\n    d.add(\n      waitForTransition(node, reason => {\n        removeClasses(node, ...to, ...base)\n        addClasses(node, ...entered)\n        return _done(reason)\n      })\n    )\n  })\n\n  // Once we get disposed, we should ensure that we cleanup after ourselves. In case of an unmount,\n  // the node itself will be nullified and will be a no-op. In case of a full transition the classes\n  // are already removed which is also a no-op. However if you go from enter -> leave mid-transition\n  // then we have some leftovers that should be cleaned.\n  d.add(() => removeClasses(node, ...base, ...from, ...to, ...entered))\n\n  // When we get disposed early, than we should also call the done method but switch the reason.\n  d.add(() => _done(Reason.Cancelled))\n\n  return d.dispose\n}\n"]},"metadata":{},"sourceType":"module"}