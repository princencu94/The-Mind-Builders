{"ast":null,"code":"import { objectWithoutPropertiesLoose as _objectWithoutPropertiesLoose, extends as _extends, createForOfIteratorHelperLoose as _createForOfIteratorHelperLoose } from '../../_virtual/_rollupPluginBabelHelpers.js';\nimport React, { useState, useMemo, useEffect, Fragment, useContext, createContext, useRef, useCallback } from 'react';\nimport { match } from '../../utils/match.esm.js';\nimport { render, RenderStrategy, Features } from '../../utils/render.esm.js';\nimport { useIsoMorphicEffect } from '../../hooks/use-iso-morphic-effect.esm.js';\nimport { useServerHandoffComplete } from '../../hooks/use-server-handoff-complete.esm.js';\nimport { useId } from '../../hooks/use-id.esm.js';\nimport { useIsMounted } from '../../hooks/use-is-mounted.esm.js';\nimport { useOpenClosed, State, OpenClosedProvider } from '../../internal/open-closed.esm.js';\nimport { useIsInitialRender } from '../../hooks/use-is-initial-render.esm.js';\nimport { transition, Reason } from './utils/transition.esm.js';\n\nfunction useSplitClasses(classes) {\n  if (classes === void 0) {\n    classes = '';\n  }\n\n  return useMemo(function () {\n    return classes.split(' ').filter(function (className) {\n      return className.trim().length > 1;\n    });\n  }, [classes]);\n}\n\nvar TransitionContext = /*#__PURE__*/createContext(null);\nTransitionContext.displayName = 'TransitionContext';\nvar TreeStates;\n\n(function (TreeStates) {\n  TreeStates[\"Visible\"] = \"visible\";\n  TreeStates[\"Hidden\"] = \"hidden\";\n})(TreeStates || (TreeStates = {}));\n\nfunction useTransitionContext() {\n  var context = useContext(TransitionContext);\n\n  if (context === null) {\n    throw new Error('A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.');\n  }\n\n  return context;\n}\n\nfunction useParentNesting() {\n  var context = useContext(NestingContext);\n\n  if (context === null) {\n    throw new Error('A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.');\n  }\n\n  return context;\n}\n\nvar NestingContext = /*#__PURE__*/createContext(null);\nNestingContext.displayName = 'NestingContext';\n\nfunction hasChildren(bag) {\n  if ('children' in bag) return hasChildren(bag.children);\n  return bag.current.filter(function (_ref) {\n    var state = _ref.state;\n    return state === TreeStates.Visible;\n  }).length > 0;\n}\n\nfunction useNesting(done) {\n  var doneRef = useRef(done);\n  var transitionableChildren = useRef([]);\n  var mounted = useIsMounted();\n  useEffect(function () {\n    doneRef.current = done;\n  }, [done]);\n  var unregister = useCallback(function (childId, strategy) {\n    var _match;\n\n    if (strategy === void 0) {\n      strategy = RenderStrategy.Hidden;\n    }\n\n    var idx = transitionableChildren.current.findIndex(function (_ref2) {\n      var id = _ref2.id;\n      return id === childId;\n    });\n    if (idx === -1) return;\n    match(strategy, (_match = {}, _match[RenderStrategy.Unmount] = function () {\n      transitionableChildren.current.splice(idx, 1);\n    }, _match[RenderStrategy.Hidden] = function () {\n      transitionableChildren.current[idx].state = TreeStates.Hidden;\n    }, _match));\n\n    if (!hasChildren(transitionableChildren) && mounted.current) {\n      doneRef.current == null ? void 0 : doneRef.current();\n    }\n  }, [doneRef, mounted, transitionableChildren]);\n  var register = useCallback(function (childId) {\n    var child = transitionableChildren.current.find(function (_ref3) {\n      var id = _ref3.id;\n      return id === childId;\n    });\n\n    if (!child) {\n      transitionableChildren.current.push({\n        id: childId,\n        state: TreeStates.Visible\n      });\n    } else if (child.state !== TreeStates.Visible) {\n      child.state = TreeStates.Visible;\n    }\n\n    return function () {\n      return unregister(childId, RenderStrategy.Unmount);\n    };\n  }, [transitionableChildren, unregister]);\n  return useMemo(function () {\n    return {\n      children: transitionableChildren,\n      register: register,\n      unregister: unregister\n    };\n  }, [register, unregister, transitionableChildren]);\n}\n\nfunction noop() {}\n\nvar eventNames = ['beforeEnter', 'afterEnter', 'beforeLeave', 'afterLeave'];\n\nfunction ensureEventHooksExist(events) {\n  var result = {};\n\n  for (var _iterator = _createForOfIteratorHelperLoose(eventNames), _step; !(_step = _iterator()).done;) {\n    var _events$name;\n\n    var name = _step.value;\n    result[name] = (_events$name = events[name]) != null ? _events$name : noop;\n  }\n\n  return result;\n}\n\nfunction useEvents(events) {\n  var eventsRef = useRef(ensureEventHooksExist(events));\n  useEffect(function () {\n    eventsRef.current = ensureEventHooksExist(events);\n  }, [events]);\n  return eventsRef;\n} // ---\n\n\nvar DEFAULT_TRANSITION_CHILD_TAG = 'div';\nvar TransitionChildRenderFeatures = Features.RenderStrategy;\n\nfunction TransitionChild(props) {\n  var _match3;\n\n  var beforeEnter = props.beforeEnter,\n      afterEnter = props.afterEnter,\n      beforeLeave = props.beforeLeave,\n      afterLeave = props.afterLeave,\n      enter = props.enter,\n      enterFrom = props.enterFrom,\n      enterTo = props.enterTo,\n      entered = props.entered,\n      leave = props.leave,\n      leaveFrom = props.leaveFrom,\n      leaveTo = props.leaveTo,\n      rest = _objectWithoutPropertiesLoose(props, [\"beforeEnter\", \"afterEnter\", \"beforeLeave\", \"afterLeave\", \"enter\", \"enterFrom\", \"enterTo\", \"entered\", \"leave\", \"leaveFrom\", \"leaveTo\"]);\n\n  var container = useRef(null);\n\n  var _useState = useState(TreeStates.Visible),\n      state = _useState[0],\n      setState = _useState[1];\n\n  var strategy = rest.unmount ? RenderStrategy.Unmount : RenderStrategy.Hidden;\n\n  var _useTransitionContext = useTransitionContext(),\n      show = _useTransitionContext.show,\n      appear = _useTransitionContext.appear,\n      initial = _useTransitionContext.initial;\n\n  var _useParentNesting = useParentNesting(),\n      register = _useParentNesting.register,\n      unregister = _useParentNesting.unregister;\n\n  var id = useId();\n  var isTransitioning = useRef(false);\n  var nesting = useNesting(function () {\n    // When all children have been unmounted we can only hide ourselves if and only if we are not\n    // transitioning ourselves. Otherwise we would unmount before the transitions are finished.\n    if (!isTransitioning.current) {\n      setState(TreeStates.Hidden);\n      unregister(id);\n      events.current.afterLeave();\n    }\n  });\n  useIsoMorphicEffect(function () {\n    if (!id) return;\n    return register(id);\n  }, [register, id]);\n  useIsoMorphicEffect(function () {\n    var _match2; // If we are in another mode than the Hidden mode then ignore\n\n\n    if (strategy !== RenderStrategy.Hidden) return;\n    if (!id) return; // Make sure that we are visible\n\n    if (show && state !== TreeStates.Visible) {\n      setState(TreeStates.Visible);\n      return;\n    }\n\n    match(state, (_match2 = {}, _match2[TreeStates.Hidden] = function () {\n      return unregister(id);\n    }, _match2[TreeStates.Visible] = function () {\n      return register(id);\n    }, _match2));\n  }, [state, id, register, unregister, show, strategy]);\n  var enterClasses = useSplitClasses(enter);\n  var enterFromClasses = useSplitClasses(enterFrom);\n  var enterToClasses = useSplitClasses(enterTo);\n  var enteredClasses = useSplitClasses(entered);\n  var leaveClasses = useSplitClasses(leave);\n  var leaveFromClasses = useSplitClasses(leaveFrom);\n  var leaveToClasses = useSplitClasses(leaveTo);\n  var events = useEvents({\n    beforeEnter: beforeEnter,\n    afterEnter: afterEnter,\n    beforeLeave: beforeLeave,\n    afterLeave: afterLeave\n  });\n  var ready = useServerHandoffComplete();\n  useEffect(function () {\n    if (ready && state === TreeStates.Visible && container.current === null) {\n      throw new Error('Did you forget to passthrough the `ref` to the actual DOM node?');\n    }\n  }, [container, state, ready]); // Skipping initial transition\n\n  var skip = initial && !appear;\n  useIsoMorphicEffect(function () {\n    var node = container.current;\n    if (!node) return;\n    if (skip) return;\n    isTransitioning.current = true;\n    if (show) events.current.beforeEnter();\n    if (!show) events.current.beforeLeave();\n    return show ? transition(node, enterClasses, enterFromClasses, enterToClasses, enteredClasses, function (reason) {\n      isTransitioning.current = false;\n      if (reason === Reason.Finished) events.current.afterEnter();\n    }) : transition(node, leaveClasses, leaveFromClasses, leaveToClasses, enteredClasses, function (reason) {\n      isTransitioning.current = false;\n      if (reason !== Reason.Finished) return; // When we don't have children anymore we can safely unregister from the parent and hide\n      // ourselves.\n\n      if (!hasChildren(nesting)) {\n        setState(TreeStates.Hidden);\n        unregister(id);\n        events.current.afterLeave();\n      }\n    });\n  }, [events, id, isTransitioning, unregister, nesting, container, skip, show, enterClasses, enterFromClasses, enterToClasses, leaveClasses, leaveFromClasses, leaveToClasses]);\n  var propsWeControl = {\n    ref: container\n  };\n  var passthroughProps = rest;\n  return React.createElement(NestingContext.Provider, {\n    value: nesting\n  }, React.createElement(OpenClosedProvider, {\n    value: match(state, (_match3 = {}, _match3[TreeStates.Visible] = State.Open, _match3[TreeStates.Hidden] = State.Closed, _match3))\n  }, render({\n    props: _extends({}, passthroughProps, propsWeControl),\n    defaultTag: DEFAULT_TRANSITION_CHILD_TAG,\n    features: TransitionChildRenderFeatures,\n    visible: state === TreeStates.Visible,\n    name: 'Transition.Child'\n  })));\n}\n\nfunction Transition(props) {\n  // @ts-expect-error\n  var show = props.show,\n      _props$appear = props.appear,\n      appear = _props$appear === void 0 ? false : _props$appear,\n      unmount = props.unmount,\n      passthroughProps = _objectWithoutPropertiesLoose(props, [\"show\", \"appear\", \"unmount\"]);\n\n  var usesOpenClosedState = useOpenClosed();\n\n  if (show === undefined && usesOpenClosedState !== null) {\n    var _match4;\n\n    show = match(usesOpenClosedState, (_match4 = {}, _match4[State.Open] = true, _match4[State.Closed] = false, _match4));\n  }\n\n  if (![true, false].includes(show)) {\n    throw new Error('A <Transition /> is used but it is missing a `show={true | false}` prop.');\n  }\n\n  var _useState2 = useState(show ? TreeStates.Visible : TreeStates.Hidden),\n      state = _useState2[0],\n      setState = _useState2[1];\n\n  var nestingBag = useNesting(function () {\n    setState(TreeStates.Hidden);\n  });\n  var initial = useIsInitialRender();\n  var transitionBag = useMemo(function () {\n    return {\n      show: show,\n      appear: appear || !initial,\n      initial: initial\n    };\n  }, [show, appear, initial]);\n  useEffect(function () {\n    if (show) {\n      setState(TreeStates.Visible);\n    } else if (!hasChildren(nestingBag)) {\n      setState(TreeStates.Hidden);\n    }\n  }, [show, nestingBag]);\n  var sharedProps = {\n    unmount: unmount\n  };\n  return React.createElement(NestingContext.Provider, {\n    value: nestingBag\n  }, React.createElement(TransitionContext.Provider, {\n    value: transitionBag\n  }, render({\n    props: _extends({}, sharedProps, {\n      as: Fragment,\n      children: React.createElement(TransitionChild, Object.assign({}, sharedProps, passthroughProps))\n    }),\n    defaultTag: Fragment,\n    features: TransitionChildRenderFeatures,\n    visible: state === TreeStates.Visible,\n    name: 'Transition'\n  })));\n}\n\nTransition.Child = function Child(props) {\n  var hasTransitionContext = useContext(TransitionContext) !== null;\n  var hasOpenClosedContext = useOpenClosed() !== null;\n  return !hasTransitionContext && hasOpenClosedContext ? React.createElement(Transition, Object.assign({}, props)) : React.createElement(TransitionChild, Object.assign({}, props));\n};\n\nTransition.Root = Transition;\nexport { Transition };","map":{"version":3,"sources":["../../../src/components/transitions/transition.tsx"],"names":["classes","useMemo","className","TransitionContext","createContext","TreeStates","context","useContext","NestingContext","hasChildren","bag","state","doneRef","useRef","transitionableChildren","mounted","useIsMounted","useEffect","unregister","useCallback","strategy","RenderStrategy","Hidden","idx","id","match","register","child","Visible","children","eventNames","result","name","events","eventsRef","ensureEventHooksExist","DEFAULT_TRANSITION_CHILD_TAG","TransitionChildRenderFeatures","Features","beforeEnter","afterEnter","beforeLeave","afterLeave","enter","enterFrom","enterTo","entered","leave","leaveFrom","leaveTo","rest","props","container","setState","useState","show","appear","initial","useTransitionContext","useParentNesting","useId","isTransitioning","nesting","useNesting","useIsoMorphicEffect","enterClasses","useSplitClasses","enterFromClasses","enterToClasses","enteredClasses","leaveClasses","leaveFromClasses","leaveToClasses","useEvents","ready","useServerHandoffComplete","skip","node","transition","reason","Reason","propsWeControl","ref","passthroughProps","value","State","render","defaultTag","features","visible","Transition","unmount","usesOpenClosedState","useOpenClosed","nestingBag","useIsInitialRender","transitionBag","sharedProps","as","React","hasTransitionContext","hasOpenClosedContext"],"mappings":"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","sourcesContent":["import React, {\n  Fragment,\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n\n  // Types\n  ElementType,\n  MutableRefObject,\n} from 'react'\nimport { Props } from '../../types'\n\nimport { useId } from '../../hooks/use-id'\nimport { useIsInitialRender } from '../../hooks/use-is-initial-render'\nimport { match } from '../../utils/match'\nimport { useIsMounted } from '../../hooks/use-is-mounted'\nimport { useIsoMorphicEffect } from '../../hooks/use-iso-morphic-effect'\n\nimport { Features, PropsForFeatures, render, RenderStrategy } from '../../utils/render'\nimport { Reason, transition } from './utils/transition'\nimport { OpenClosedProvider, State, useOpenClosed } from '../../internal/open-closed'\nimport { useServerHandoffComplete } from '../../hooks/use-server-handoff-complete'\n\ntype ID = ReturnType<typeof useId>\n\nfunction useSplitClasses(classes: string = '') {\n  return useMemo(() => classes.split(' ').filter(className => className.trim().length > 1), [\n    classes,\n  ])\n}\n\ninterface TransitionContextValues {\n  show: boolean\n  appear: boolean\n  initial: boolean\n}\nlet TransitionContext = createContext<TransitionContextValues | null>(null)\nTransitionContext.displayName = 'TransitionContext'\n\nenum TreeStates {\n  Visible = 'visible',\n  Hidden = 'hidden',\n}\n\nexport interface TransitionClasses {\n  enter?: string\n  enterFrom?: string\n  enterTo?: string\n  entered?: string\n  leave?: string\n  leaveFrom?: string\n  leaveTo?: string\n}\n\nexport interface TransitionEvents {\n  beforeEnter?: () => void\n  afterEnter?: () => void\n  beforeLeave?: () => void\n  afterLeave?: () => void\n}\n\ntype TransitionChildProps<TTag> = Props<TTag, TransitionChildRenderPropArg> &\n  PropsForFeatures<typeof TransitionChildRenderFeatures> &\n  TransitionClasses &\n  TransitionEvents & { appear?: boolean }\n\nfunction useTransitionContext() {\n  let context = useContext(TransitionContext)\n\n  if (context === null) {\n    throw new Error(\n      'A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.'\n    )\n  }\n\n  return context\n}\n\nfunction useParentNesting() {\n  let context = useContext(NestingContext)\n\n  if (context === null) {\n    throw new Error(\n      'A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.'\n    )\n  }\n\n  return context\n}\n\ninterface NestingContextValues {\n  children: MutableRefObject<{ id: ID; state: TreeStates }[]>\n  register: (id: ID) => () => void\n  unregister: (id: ID, strategy?: RenderStrategy) => void\n}\n\nlet NestingContext = createContext<NestingContextValues | null>(null)\nNestingContext.displayName = 'NestingContext'\n\nfunction hasChildren(\n  bag: NestingContextValues['children'] | { children: NestingContextValues['children'] }\n): boolean {\n  if ('children' in bag) return hasChildren(bag.children)\n  return bag.current.filter(({ state }) => state === TreeStates.Visible).length > 0\n}\n\nfunction useNesting(done?: () => void) {\n  let doneRef = useRef(done)\n  let transitionableChildren = useRef<NestingContextValues['children']['current']>([])\n  let mounted = useIsMounted()\n\n  useEffect(() => {\n    doneRef.current = done\n  }, [done])\n\n  let unregister = useCallback(\n    (childId: ID, strategy = RenderStrategy.Hidden) => {\n      let idx = transitionableChildren.current.findIndex(({ id }) => id === childId)\n      if (idx === -1) return\n\n      match(strategy, {\n        [RenderStrategy.Unmount]() {\n          transitionableChildren.current.splice(idx, 1)\n        },\n        [RenderStrategy.Hidden]() {\n          transitionableChildren.current[idx].state = TreeStates.Hidden\n        },\n      })\n\n      if (!hasChildren(transitionableChildren) && mounted.current) {\n        doneRef.current?.()\n      }\n    },\n    [doneRef, mounted, transitionableChildren]\n  )\n\n  let register = useCallback(\n    (childId: ID) => {\n      let child = transitionableChildren.current.find(({ id }) => id === childId)\n      if (!child) {\n        transitionableChildren.current.push({ id: childId, state: TreeStates.Visible })\n      } else if (child.state !== TreeStates.Visible) {\n        child.state = TreeStates.Visible\n      }\n\n      return () => unregister(childId, RenderStrategy.Unmount)\n    },\n    [transitionableChildren, unregister]\n  )\n\n  return useMemo(\n    () => ({\n      children: transitionableChildren,\n      register,\n      unregister,\n    }),\n    [register, unregister, transitionableChildren]\n  )\n}\n\nfunction noop() {}\nlet eventNames = ['beforeEnter', 'afterEnter', 'beforeLeave', 'afterLeave'] as const\nfunction ensureEventHooksExist(events: TransitionEvents) {\n  let result = {} as Record<keyof typeof events, () => void>\n  for (let name of eventNames) {\n    result[name] = events[name] ?? noop\n  }\n  return result\n}\n\nfunction useEvents(events: TransitionEvents) {\n  let eventsRef = useRef(ensureEventHooksExist(events))\n\n  useEffect(() => {\n    eventsRef.current = ensureEventHooksExist(events)\n  }, [events])\n\n  return eventsRef\n}\n\n// ---\n\nlet DEFAULT_TRANSITION_CHILD_TAG = 'div' as const\ntype TransitionChildRenderPropArg = MutableRefObject<HTMLDivElement>\nlet TransitionChildRenderFeatures = Features.RenderStrategy\n\nfunction TransitionChild<TTag extends ElementType = typeof DEFAULT_TRANSITION_CHILD_TAG>(\n  props: TransitionChildProps<TTag>\n) {\n  let {\n    // Event \"handlers\"\n    beforeEnter,\n    afterEnter,\n    beforeLeave,\n    afterLeave,\n\n    // Class names\n    enter,\n    enterFrom,\n    enterTo,\n    entered,\n    leave,\n    leaveFrom,\n    leaveTo,\n\n    // @ts-expect-error\n    ...rest\n  } = props as typeof props\n  let container = useRef<HTMLElement | null>(null)\n  let [state, setState] = useState(TreeStates.Visible)\n  let strategy = rest.unmount ? RenderStrategy.Unmount : RenderStrategy.Hidden\n\n  let { show, appear, initial } = useTransitionContext()\n  let { register, unregister } = useParentNesting()\n\n  let id = useId()\n\n  let isTransitioning = useRef(false)\n\n  let nesting = useNesting(() => {\n    // When all children have been unmounted we can only hide ourselves if and only if we are not\n    // transitioning ourselves. Otherwise we would unmount before the transitions are finished.\n    if (!isTransitioning.current) {\n      setState(TreeStates.Hidden)\n      unregister(id)\n      events.current.afterLeave()\n    }\n  })\n\n  useIsoMorphicEffect(() => {\n    if (!id) return\n    return register(id)\n  }, [register, id])\n\n  useIsoMorphicEffect(() => {\n    // If we are in another mode than the Hidden mode then ignore\n    if (strategy !== RenderStrategy.Hidden) return\n    if (!id) return\n\n    // Make sure that we are visible\n    if (show && state !== TreeStates.Visible) {\n      setState(TreeStates.Visible)\n      return\n    }\n\n    match(state, {\n      [TreeStates.Hidden]: () => unregister(id),\n      [TreeStates.Visible]: () => register(id),\n    })\n  }, [state, id, register, unregister, show, strategy])\n\n  let enterClasses = useSplitClasses(enter)\n  let enterFromClasses = useSplitClasses(enterFrom)\n  let enterToClasses = useSplitClasses(enterTo)\n\n  let enteredClasses = useSplitClasses(entered)\n\n  let leaveClasses = useSplitClasses(leave)\n  let leaveFromClasses = useSplitClasses(leaveFrom)\n  let leaveToClasses = useSplitClasses(leaveTo)\n\n  let events = useEvents({ beforeEnter, afterEnter, beforeLeave, afterLeave })\n\n  let ready = useServerHandoffComplete()\n\n  useEffect(() => {\n    if (ready && state === TreeStates.Visible && container.current === null) {\n      throw new Error('Did you forget to passthrough the `ref` to the actual DOM node?')\n    }\n  }, [container, state, ready])\n\n  // Skipping initial transition\n  let skip = initial && !appear\n\n  useIsoMorphicEffect(() => {\n    let node = container.current\n    if (!node) return\n    if (skip) return\n\n    isTransitioning.current = true\n\n    if (show) events.current.beforeEnter()\n    if (!show) events.current.beforeLeave()\n\n    return show\n      ? transition(node, enterClasses, enterFromClasses, enterToClasses, enteredClasses, reason => {\n          isTransitioning.current = false\n          if (reason === Reason.Finished) events.current.afterEnter()\n        })\n      : transition(node, leaveClasses, leaveFromClasses, leaveToClasses, enteredClasses, reason => {\n          isTransitioning.current = false\n\n          if (reason !== Reason.Finished) return\n\n          // When we don't have children anymore we can safely unregister from the parent and hide\n          // ourselves.\n          if (!hasChildren(nesting)) {\n            setState(TreeStates.Hidden)\n            unregister(id)\n            events.current.afterLeave()\n          }\n        })\n  }, [\n    events,\n    id,\n    isTransitioning,\n    unregister,\n    nesting,\n    container,\n    skip,\n    show,\n    enterClasses,\n    enterFromClasses,\n    enterToClasses,\n    leaveClasses,\n    leaveFromClasses,\n    leaveToClasses,\n  ])\n\n  let propsWeControl = { ref: container }\n  let passthroughProps = rest\n\n  return (\n    <NestingContext.Provider value={nesting}>\n      <OpenClosedProvider\n        value={match(state, {\n          [TreeStates.Visible]: State.Open,\n          [TreeStates.Hidden]: State.Closed,\n        })}\n      >\n        {render({\n          props: { ...passthroughProps, ...propsWeControl },\n          defaultTag: DEFAULT_TRANSITION_CHILD_TAG,\n          features: TransitionChildRenderFeatures,\n          visible: state === TreeStates.Visible,\n          name: 'Transition.Child',\n        })}\n      </OpenClosedProvider>\n    </NestingContext.Provider>\n  )\n}\n\nexport function Transition<TTag extends ElementType = typeof DEFAULT_TRANSITION_CHILD_TAG>(\n  props: TransitionChildProps<TTag> & { show?: boolean; appear?: boolean }\n) {\n  // @ts-expect-error\n  let { show, appear = false, unmount, ...passthroughProps } = props as typeof props\n\n  let usesOpenClosedState = useOpenClosed()\n\n  if (show === undefined && usesOpenClosedState !== null) {\n    show = match(usesOpenClosedState, {\n      [State.Open]: true,\n      [State.Closed]: false,\n    })\n  }\n\n  if (![true, false].includes((show as unknown) as boolean)) {\n    throw new Error('A <Transition /> is used but it is missing a `show={true | false}` prop.')\n  }\n\n  let [state, setState] = useState(show ? TreeStates.Visible : TreeStates.Hidden)\n\n  let nestingBag = useNesting(() => {\n    setState(TreeStates.Hidden)\n  })\n\n  let initial = useIsInitialRender()\n  let transitionBag = useMemo<TransitionContextValues>(\n    () => ({ show: show as boolean, appear: appear || !initial, initial }),\n    [show, appear, initial]\n  )\n\n  useEffect(() => {\n    if (show) {\n      setState(TreeStates.Visible)\n    } else if (!hasChildren(nestingBag)) {\n      setState(TreeStates.Hidden)\n    }\n  }, [show, nestingBag])\n\n  let sharedProps = { unmount }\n\n  return (\n    <NestingContext.Provider value={nestingBag}>\n      <TransitionContext.Provider value={transitionBag}>\n        {render({\n          props: {\n            ...sharedProps,\n            as: Fragment,\n            children: <TransitionChild {...sharedProps} {...passthroughProps} />,\n          },\n          defaultTag: Fragment,\n          features: TransitionChildRenderFeatures,\n          visible: state === TreeStates.Visible,\n          name: 'Transition',\n        })}\n      </TransitionContext.Provider>\n    </NestingContext.Provider>\n  )\n}\n\nTransition.Child = function Child<TTag extends ElementType = typeof DEFAULT_TRANSITION_CHILD_TAG>(\n  props: TransitionChildProps<TTag>\n) {\n  let hasTransitionContext = useContext(TransitionContext) !== null\n  let hasOpenClosedContext = useOpenClosed() !== null\n\n  return !hasTransitionContext && hasOpenClosedContext ? (\n    <Transition {...props} />\n  ) : (\n    <TransitionChild {...props} />\n  )\n}\nTransition.Root = Transition\n"]},"metadata":{},"sourceType":"module"}