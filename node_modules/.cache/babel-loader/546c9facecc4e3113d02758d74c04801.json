{"ast":null,"code":"import { createForOfIteratorHelperLoose as _createForOfIteratorHelperLoose } from '../_virtual/_rollupPluginBabelHelpers.js';\nimport { useRef, useEffect } from 'react';\nimport { Keys } from '../components/keyboard.esm.js';\nimport { focusElement, focusIn, Focus, FocusResult } from '../utils/focus-management.esm.js';\nimport { useWindowEvent } from './use-window-event.esm.js';\nimport { useIsMounted } from './use-is-mounted.esm.js';\nvar Features;\n\n(function (Features) {\n  /** No features enabled for the `useFocusTrap` hook. */\n  Features[Features[\"None\"] = 1] = \"None\";\n  /** Ensure that we move focus initially into the container. */\n\n  Features[Features[\"InitialFocus\"] = 2] = \"InitialFocus\";\n  /** Ensure that pressing `Tab` and `Shift+Tab` is trapped within the container. */\n\n  Features[Features[\"TabLock\"] = 4] = \"TabLock\";\n  /** Ensure that programmatically moving focus outside of the container is disallowed. */\n\n  Features[Features[\"FocusLock\"] = 8] = \"FocusLock\";\n  /** Ensure that we restore the focus when unmounting the component that uses this `useFocusTrap` hook. */\n\n  Features[Features[\"RestoreFocus\"] = 16] = \"RestoreFocus\";\n  /** Enable all features. */\n\n  Features[Features[\"All\"] = 30] = \"All\";\n})(Features || (Features = {}));\n\nfunction useFocusTrap(container, features, _temp) {\n  if (features === void 0) {\n    features = Features.All;\n  }\n\n  var _ref = _temp === void 0 ? {} : _temp,\n      initialFocus = _ref.initialFocus,\n      containers = _ref.containers;\n\n  var restoreElement = useRef(typeof window !== 'undefined' ? document.activeElement : null);\n  var previousActiveElement = useRef(null);\n  var mounted = useIsMounted();\n  var featuresRestoreFocus = Boolean(features & Features.RestoreFocus);\n  var featuresInitialFocus = Boolean(features & Features.InitialFocus); // Capture the currently focused element, before we enable the focus trap.\n\n  useEffect(function () {\n    if (!featuresRestoreFocus) return;\n    restoreElement.current = document.activeElement;\n  }, [featuresRestoreFocus]); // Restore the focus when we unmount the component.\n\n  useEffect(function () {\n    if (!featuresRestoreFocus) return;\n    return function () {\n      focusElement(restoreElement.current);\n      restoreElement.current = null;\n    };\n  }, [featuresRestoreFocus]); // Handle initial focus\n\n  useEffect(function () {\n    if (!featuresInitialFocus) return;\n    if (!container.current) return;\n    var activeElement = document.activeElement;\n\n    if (initialFocus == null ? void 0 : initialFocus.current) {\n      if ((initialFocus == null ? void 0 : initialFocus.current) === activeElement) {\n        previousActiveElement.current = activeElement;\n        return; // Initial focus ref is already the active element\n      }\n    } else if (container.current.contains(activeElement)) {\n      previousActiveElement.current = activeElement;\n      return; // Already focused within Dialog\n    } // Try to focus the initialFocus ref\n\n\n    if (initialFocus == null ? void 0 : initialFocus.current) {\n      focusElement(initialFocus.current);\n    } else {\n      if (focusIn(container.current, Focus.First) === FocusResult.Error) {\n        console.warn('There are no focusable elements inside the <FocusTrap />');\n      }\n    }\n\n    previousActiveElement.current = document.activeElement;\n  }, [container, initialFocus, featuresInitialFocus]); // Handle `Tab` & `Shift+Tab` keyboard events\n\n  useWindowEvent('keydown', function (event) {\n    if (!(features & Features.TabLock)) return;\n    if (!container.current) return;\n    if (event.key !== Keys.Tab) return;\n    event.preventDefault();\n\n    if (focusIn(container.current, (event.shiftKey ? Focus.Previous : Focus.Next) | Focus.WrapAround) === FocusResult.Success) {\n      previousActiveElement.current = document.activeElement;\n    }\n  }); // Prevent programmatically escaping the container\n\n  useWindowEvent('focus', function (event) {\n    if (!(features & Features.FocusLock)) return;\n    var allContainers = new Set(containers == null ? void 0 : containers.current);\n    allContainers.add(container);\n    if (!allContainers.size) return;\n    var previous = previousActiveElement.current;\n    if (!previous) return;\n    if (!mounted.current) return;\n    var toElement = event.target;\n\n    if (toElement && toElement instanceof HTMLElement) {\n      if (!contains(allContainers, toElement)) {\n        event.preventDefault();\n        event.stopPropagation();\n        focusElement(previous);\n      } else {\n        previousActiveElement.current = toElement;\n        focusElement(toElement);\n      }\n    } else {\n      focusElement(previousActiveElement.current);\n    }\n  }, true);\n}\n\nfunction contains(containers, element) {\n  for (var _iterator = _createForOfIteratorHelperLoose(containers), _step; !(_step = _iterator()).done;) {\n    var _container$current;\n\n    var container = _step.value;\n    if ((_container$current = container.current) == null ? void 0 : _container$current.contains(element)) return true;\n  }\n\n  return false;\n}\n\nexport { Features, useFocusTrap };","map":{"version":3,"sources":["../../src/hooks/use-focus-trap.ts"],"names":["Features","useFocusTrap","container","features","All","initialFocus","containers","restoreElement","useRef","document","previousActiveElement","mounted","useIsMounted","featuresRestoreFocus","Boolean","featuresInitialFocus","useEffect","focusElement","activeElement","focusIn","Focus","FocusResult","console","useWindowEvent","event","Keys","allContainers","previous","toElement","contains"],"mappings":"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","sourcesContent":["import {\n  useRef,\n  // Types\n  MutableRefObject,\n  useEffect,\n} from 'react'\n\nimport { Keys } from '../components/keyboard'\nimport { focusElement, focusIn, Focus, FocusResult } from '../utils/focus-management'\nimport { useWindowEvent } from './use-window-event'\nimport { useIsMounted } from './use-is-mounted'\n\nexport enum Features {\n  /** No features enabled for the `useFocusTrap` hook. */\n  None = 1 << 0,\n\n  /** Ensure that we move focus initially into the container. */\n  InitialFocus = 1 << 1,\n\n  /** Ensure that pressing `Tab` and `Shift+Tab` is trapped within the container. */\n  TabLock = 1 << 2,\n\n  /** Ensure that programmatically moving focus outside of the container is disallowed. */\n  FocusLock = 1 << 3,\n\n  /** Ensure that we restore the focus when unmounting the component that uses this `useFocusTrap` hook. */\n  RestoreFocus = 1 << 4,\n\n  /** Enable all features. */\n  All = InitialFocus | TabLock | FocusLock | RestoreFocus,\n}\n\nexport function useFocusTrap(\n  container: MutableRefObject<HTMLElement | null>,\n  features: Features = Features.All,\n  {\n    initialFocus,\n    containers,\n  }: {\n    initialFocus?: MutableRefObject<HTMLElement | null>\n    containers?: MutableRefObject<Set<MutableRefObject<HTMLElement | null>>>\n  } = {}\n) {\n  let restoreElement = useRef<HTMLElement | null>(\n    typeof window !== 'undefined' ? (document.activeElement as HTMLElement) : null\n  )\n  let previousActiveElement = useRef<HTMLElement | null>(null)\n  let mounted = useIsMounted()\n\n  let featuresRestoreFocus = Boolean(features & Features.RestoreFocus)\n  let featuresInitialFocus = Boolean(features & Features.InitialFocus)\n\n  // Capture the currently focused element, before we enable the focus trap.\n  useEffect(() => {\n    if (!featuresRestoreFocus) return\n\n    restoreElement.current = document.activeElement as HTMLElement\n  }, [featuresRestoreFocus])\n\n  // Restore the focus when we unmount the component.\n  useEffect(() => {\n    if (!featuresRestoreFocus) return\n\n    return () => {\n      focusElement(restoreElement.current)\n      restoreElement.current = null\n    }\n  }, [featuresRestoreFocus])\n\n  // Handle initial focus\n  useEffect(() => {\n    if (!featuresInitialFocus) return\n    if (!container.current) return\n\n    let activeElement = document.activeElement as HTMLElement\n\n    if (initialFocus?.current) {\n      if (initialFocus?.current === activeElement) {\n        previousActiveElement.current = activeElement\n        return // Initial focus ref is already the active element\n      }\n    } else if (container.current.contains(activeElement)) {\n      previousActiveElement.current = activeElement\n      return // Already focused within Dialog\n    }\n\n    // Try to focus the initialFocus ref\n    if (initialFocus?.current) {\n      focusElement(initialFocus.current)\n    } else {\n      if (focusIn(container.current, Focus.First) === FocusResult.Error) {\n        console.warn('There are no focusable elements inside the <FocusTrap />')\n      }\n    }\n\n    previousActiveElement.current = document.activeElement as HTMLElement\n  }, [container, initialFocus, featuresInitialFocus])\n\n  // Handle `Tab` & `Shift+Tab` keyboard events\n  useWindowEvent('keydown', event => {\n    if (!(features & Features.TabLock)) return\n\n    if (!container.current) return\n    if (event.key !== Keys.Tab) return\n\n    event.preventDefault()\n\n    if (\n      focusIn(\n        container.current,\n        (event.shiftKey ? Focus.Previous : Focus.Next) | Focus.WrapAround\n      ) === FocusResult.Success\n    ) {\n      previousActiveElement.current = document.activeElement as HTMLElement\n    }\n  })\n\n  // Prevent programmatically escaping the container\n  useWindowEvent(\n    'focus',\n    event => {\n      if (!(features & Features.FocusLock)) return\n\n      let allContainers = new Set(containers?.current)\n      allContainers.add(container)\n\n      if (!allContainers.size) return\n\n      let previous = previousActiveElement.current\n      if (!previous) return\n      if (!mounted.current) return\n\n      let toElement = event.target as HTMLElement | null\n\n      if (toElement && toElement instanceof HTMLElement) {\n        if (!contains(allContainers, toElement)) {\n          event.preventDefault()\n          event.stopPropagation()\n          focusElement(previous)\n        } else {\n          previousActiveElement.current = toElement\n          focusElement(toElement)\n        }\n      } else {\n        focusElement(previousActiveElement.current)\n      }\n    },\n    true\n  )\n}\n\nfunction contains(containers: Set<MutableRefObject<HTMLElement | null>>, element: HTMLElement) {\n  for (let container of containers) {\n    if (container.current?.contains(element)) return true\n  }\n\n  return false\n}\n"]},"metadata":{},"sourceType":"module"}